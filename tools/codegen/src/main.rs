#![warn(rust_2018_idioms, single_use_lifetimes)]

use std::{
    collections::BTreeSet,
    path::{Path, PathBuf},
};

use anyhow::Result;
use quote::{format_ident, quote};
use walkdir::WalkDir;

fn main() -> Result<()> {
    gen_from_str()?;
    gen_assert_impl()?;
    Ok(())
}

fn root_dir() -> PathBuf {
    let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    dir.pop(); // codegen
    dir.pop(); // tools
    dir
}

fn gen_from_str() -> Result<()> {
    let root_dir = &root_dir();

    let mut out = String::new();
    out += "// This file is @generated by dependabot-config-internal-codegen.\n";
    out += "// It is not intended for manual editing.\n";
    out += "\n";

    let mut tokens = quote! {
        use std::str::FromStr;
        use crate::*;
    };

    for &f in &["src/lib.rs", "src/v2.rs"] {
        let s = fs::read_to_string(root_dir.join(f))?;
        let ast = syn::parse_file(&s)?;

        let module = if f.ends_with("lib.rs") {
            quote! {}
        } else {
            let name = format_ident!("{}", Path::new(f).file_stem().unwrap().to_string_lossy());
            quote! { #name:: }
        };

        for i in ast.items {
            match i {
                syn::Item::Struct(syn::ItemStruct { vis, ident, .. })
                | syn::Item::Enum(syn::ItemEnum { vis, ident, .. })
                    if matches!(vis, syn::Visibility::Public(..)) =>
                {
                    tokens.extend(quote! {
                        impl FromStr for #module#ident {
                            type Err = Error;
                            fn from_str(s: &str) -> Result<Self, Self::Err> {
                                serde_yaml::from_str(s).map_err(Error::new)
                            }
                        }
                    });
                }
                _ => {}
            }
        }
    }

    out += &tokens.to_string();

    fs::write(root_dir.join("src/gen/from_str.rs"), out)?;

    Ok(())
}

fn gen_assert_impl() -> Result<()> {
    let root_dir = &root_dir();

    let mut out = String::new();
    out += "// This file is @generated by dependabot-config-internal-codegen.\n";
    out += "// It is not intended for manual editing.\n";
    out += "\n";

    let mut tokens = quote! {
        use static_assertions::assert_impl_all as assert_impl;
        use crate::*;
    };

    let files: BTreeSet<String> = WalkDir::new(root_dir.join("src"))
        .into_iter()
        .filter_map(Result::ok)
        .filter_map(|e| {
            let path = e.path();
            if !path.is_file() || path.extension() != Some("rs".as_ref()) {
                return None;
            }
            Some(path.to_string_lossy().into_owned())
        })
        .collect();
    for f in &files {
        let s = fs::read_to_string(f)?;
        let ast = syn::parse_file(&s)?;

        let module = if f.ends_with("lib.rs") {
            quote! {}
        } else {
            let name = format_ident!("{}", Path::new(f).file_stem().unwrap().to_string_lossy());
            quote! { #name:: }
        };

        for i in ast.items {
            match i {
                syn::Item::Struct(syn::ItemStruct { vis, ident, .. })
                | syn::Item::Enum(syn::ItemEnum { vis, ident, .. })
                    if matches!(vis, syn::Visibility::Public(..)) =>
                {
                    tokens.extend(quote! {
                        assert_impl!(#module#ident: Send);
                        assert_impl!(#module#ident: Sync);
                        assert_impl!(#module#ident: Unpin);
                    });
                }
                _ => {}
            }
        }
    }

    out += &tokens.to_string();

    fs::write(root_dir.join("src/gen/assert_impl.rs"), out)?;

    Ok(())
}
